

题目：求子数组的最大和
输入一个整形数组，数组里有正数也有负数。
数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。
求所有子数组的和的最大值。要求时间复杂度为O(n)。

例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，
因此输出为该子数组的和18。

1. 蛮力法 fmax(i,j) 找出最大的值，3重循环 ，复杂度 0(n^3)
2. 




最长公共子序列 （动态规划的经典题目） 




编程求解：
输入两个整数 n 和 m，从数列1，2，3.......n 中 随意取几个数,使其和等于 m ,要求将其中所有的可能组合列出来.

print_sum_detials(int n , int sum)

动态规划（类似背包问题）






查找最小的k个元素
题目：输入n个整数，输出其中最小的k个。
例如输入1，2，3，4，5，6，7和8这8个数字，则最小的4个数字为1，2，3和4。

print_minimums(int *a,int length ,int k);




题目：输入一个已经按升序排序过的数组和一个数字，
在数组中查找两个数，使得它们的和正好是输入的那个数字。
要求时间复杂度是O(n)。如果有多对数字的和等于输入的数字，输出任意一对即可。
例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。



给出两个集合A和B，其中集合A={name}，
集合B={age、sex、scholarship、address、...}，
要求：
问题1、根据集合A中的name查询出集合B中对应的属性信息；
问题2、根据集合B中的属性信息（单个属性，如age<20等），查询出集合A中对应的name。





题目：
输入a1,a2,...,an,b1,b2,...,bn, 
在O(n)的时间,O(1)的空间将这个序列顺序改为a1,b1,a2,b2,a3,b3,...,an,bn，
且不需要移动，通过交换完成，只需一个交换空间。

例如，N=9时，第2步执行后，实际上中间位置的两边对称的4个元素基本配对，
只需交换中间的两个元素即可，如下表所示。颜色表示每次要交换的元素,左边向右交换,右边向左交换。
交换过程如下表所示
交换x1,x3；交换x2,x4；再交换中间的x1,x4；交换y1,y2。



   
给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数   
要求下排每个数都是先前上排那十个数在下排出现的次数。   
上排的十个数如下：   
【0，1，2，3，4，5，6，7，8，9】

初看此题，貌似很难，10分钟过去了，可能有的人，题目都还没看懂。   

举一个例子，   
数值: 0,1,2,3,4,5,6,7,8,9   
分配: 6,2,1,0,0,0,1,0,0,0   
0在下排出现了6次，1在下排出现了2次，   
2在下排出现了1次，3在下排出现了0次....   
以此类推..   

昨天，花了一个下午，用c++实现了此题。(*^__^*)  






题目：n个数字（0,1,…,n-1）形成一个圆圈，从数字0开始，
每次从这个圆圈中删除第m个数字（第一个为当前数字本身，第二个为当前数字的下一个数字）。
当一个数字删除后，从被删除数字的下一个继续删除第m个数字。
求出在这个圆圈中剩下的最后一个数字。

如 0,1,2,3,4,5 删除第2个数字 （n=6，m=2）
第一次删除：1
第二次删除: 3
第三次删除：5 
第四次删除：2 
因此，左后的一个数字就是 4 



用最简单， 最快速的方法计算出下面这个圆形是否和正方形相交。"  
3D坐标系 原点(0.0,0.0,0.0)
圆形:
半径r = 3.0
圆心o = (*.*, 0.0, *.*)

正方形:
4个角坐标;  
1:(*.*, 0.0, *.*)
2:(*.*, 0.0, *.*)
3:(*.*, 0.0, *.*)
4:(*.*, 0.0, *.*)


 

有两个序列a,b，大小都为n,序列元素的值任意整数，无序；
要求：通过交换a,b中的元素，使[序列a元素的和]与[序列b元素的和]之间的差最小。
例如:   
var a=[100,99,98,1,2, 3];
var b=[1, 2, 3, 4,5,40];



一个整数数组，长度为n，将其分为m份，使各份的和相等，求m的最大值
  比如{3，2，4，3，6} 可以分成{3，2，4，3，6} m=1; 
  {3,6}{2,4,3} m=2
  {3,3}{2,4}{6} m=3 所以m的最大值为3

 


n支队伍比赛，分别编号为0，1，2。。。。n-1，已知它们之间的实力对比关系，
存储在一个二维数组w[n][n]中，w[i][j] 的值代表编号为i，j的队伍中更强的一支。

所以w[i][j]=i 或者j，现在给出它们的出场顺序，并存储在数组order[n]中，
比如order[n] = {4,3,5,8,1......}，那么第一轮比赛就是 4对3， 5对8。.......

胜者晋级，败者淘汰，同一轮淘汰的所有队伍排名不再细分，即可以随便排，
下一轮由上一轮的胜者按照顺序，再依次两两比，比如可能是4对5,直至出现第一名

编程实现，给出二维数组w，一维数组order 和 用于输出比赛名次的数组result[n]，求出result。



一个int数组，里面数据无任何限制，要求求出所有这样的数a[i]，
其左边的数都小于等于它，右边的数都大于等于它。
能否只用一个额外数组和少量其它空间实现。




一个未排序整数数组，有正负数，重新排列使负数排在正数前面，并且要求不改变原来的正负数之间相对顺序 比如： input: 1,7,-5,9,-12,15 ans: -5,-12,1,7,9,15 要求时间复杂度O(N),空间O(1) 。（此题一直没看到令我满意的答案，一般达不到题目所要求的：时间复杂度O(N),空间O(1)，且保证原来正负数之间的相对位置不变）。
updated：设置一个起始点j, 一个翻转点k,一个终止点L
从右侧起
起始点在第一个出现的负数, 翻转点在起始点后第一个出现的正数,终止点在翻转点后出现的第一个负数(或结束)
如果无翻转点, 则不操作
如果有翻转点, 则待终止点出现后, 做翻转, 即ab => ba 这样的操作
翻转后, 负数串一定在左侧, 然后从负数串的右侧开始记录起始点, 继续往下找下一个翻转点
  
例子中的就是

1, 7, -5, 9, -12, 15  
第一次翻转: 1, 7, -5, -12,9, 15   =>  1, -12, -5, 7, 9, 15
第二次翻转: -5, -12, 1, 7, 9, 15

    N维翻转空间占用为O(1)复杂度是2N；在有一个负数的情况下, 复杂度最大是2N, ；在有i个负数的情况下, 复杂度最大是2N+2i, 但是不会超过2N+N实际的复杂度在O(3N)以内 
    但从最终时间复杂度分析，此方法是否真能达到O（N）的时间复杂度，还待后续考证。感谢John_Lv，MikovChain。2012.02.25。

1, 7, -5, -6， 9, -12, 15（后续：此种情况未能处理）
1 7 -5 -6 -12 9 15
1 -12 -5 -6 7 9 15
-6 -12 -5 1 7 9 15

更多请参考此文，程序员编程艺术第二十七章：重新排列数组（不改变相对顺序&时间O(N)&空间O(1)，半年未被KO）http://blog.csdn.net/v_july_v/article/details/7329314。


给定一个实数数组，按序排列（从小到大）,从数组从找出若干个数，使得这若干个数的和与M最为接近，描述一个算法，并给出算法的复杂度。



1. 有无序的实数列V[N]，要求求里面大小相邻的实数的差的最大值，关键是要求线性空间和线性时间

3. 有一个函数int getNum()，每运行一次可以从一个数组V[N]里面取出一个数，N未知，当数取完的时候，函数返回NULL。现在要求写一个函数int get()，这个函数运行一次可以从V[N]里随机取出一个数，而这个数必须是符合1/N平均分布的，也就是说V[N]里面任意一个数都有1/N的机会被取出，要求空间复杂度为O（1）




21、搜狗笔试题：一个长度为n的数组a[0],a[1],...,a[n-1]。现在更新数组的名个元素，即a[0]变为a[1]到a[n-1]的积，a[1]变为a[0]和a[2]到a[n-1]的积，...，a[n-1]为a[0]到a[n-2]的积（就是除掉当前元素，其他所有元素的积）。程序要求：具有线性复杂度，且不能使用除法运算符。

    思路：left[i]标示着a[i]之前的乘积，right[i]标示着a[i]之后的乘积，但不申请空间，那么a[i]=left[i]*right[i] 。不过，left的计算从左往右扫的时候得出，right是从右往左扫得出。因为就是当中某个元素a[i]的左边所有元素与右边所有元素的乘积，就这么简单。所以计算a[i]=left[i]*right[i]时，直接出结果。



22、后2012年4月6日的腾讯暑期实习生招聘笔试中，出了一道与上述21题类似的题，原题大致如下：

    两个数组a[N]，b[N]，其中A[N]的各个元素值已知，现给b[i]赋值，b[i] = a[0]*a[1]*a[2]...*a[N-1]/a[i]；
要求：
    1.不准用除法运算
    2.除了循环计数值，a[N],b[N]外，不准再用其他任何变量（包括局部变量，全局变量等）
    3.满足时间复杂度O（n），空间复杂度O（1）。

    说白了，你要我求b=a[0]*a*...a[i-1]*a*a[i+1]..*a[N-1]/a ，就是求：a[0]*a[1]*...a[i-1]*a[i+1]..*a[N-1]。只是我把a[i]左边部分标示为left[i]，b[i]右边部分标示为right[i]，而实际上完全不申请left[i]，与right[i]变量，之所以那样标示，无非就是为了说明：除掉当前元素a[i]，其他所有元素(a[i]左边部分，和a[i]右边部分)的积。读者你明白了么?

    下面是此TX笔试题的两段参考代码，如下：



//ncicc  
b[0] = 1;  
for (int i = 1; i < N; i++)  
{  
  b[0] *= a[i-1];  
  b[i] = b[0];  
}  
b[0] = 1;  
for (i = N-2; i > 0; i--)  
{  
  b[0] *= a[i+1];  
  b[i] *= b[0];  
}  
b[0] *= a[1];  
    from wasd6081058上面第二段代码最后一行的意义是：我们看第二个循环，从N-2到 1；再看for循环中b[0]的赋值，从N-1到2，而根据题目要求b[i] = a[0]*a[1]*a[2]...*a[N-1]/a[i]，b[0]应等于a[1]*a[2]* ....a[N-1],所以这里手动添加a[1]。
  此外，也有朋友在微博上：http://weibo.com/1761944724/ydwuMt9bH 给出了另外一种解法，如下图所示：
      



94.微软笔试题
求随机数构成的数组中找到长度大于=3的最长的等差数列9 d- x' W) w9 ?" o3 b0 R
输出等差数列由小到大: 
如果没有符合条件的就输出
格式：
输入[1,3,0,5,-1,6]
输出[-1,1,3,5]
要求时间复杂度，空间复杂度尽量小




93.在一个int数组里查找这样的数，它大于等于左侧所有数，小于等于右侧所有数。
直观想法是用两个数组a、b。a[i]、b[i]分别保存从前到i的最大的数和从后到i的最小的数，
一个解答：这需要两次遍历，然后再遍历一次原数组，
将所有data[i]>=a[i-1]&&data[i]<=b[i]的data[i]找出即可。
给出这个解答后，面试官有要求只能用一个辅助数组，且要求少遍历一次。
 



第19题：
题目：定义Fibonacci数列如下：   
  / 0 n=0
f(n)= 1 n=1
  / f(n-1)+f(n-2) n=2

输入n，用最快的方法求该数列的第n项。
分析：在很多C语言教科书中讲到递归函数的时候，都会用Fibonacci作为例子。
因此很多程序员对这道题的递归解法非常熟悉，但....呵呵，你知道的。。


寻址重复的元素
1.a~z包括大小写与0~9组成的N个数
用最快的方式把其中重复的元素挑出来。




74.数组中超过出现次数超过一半的数字
题目：数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。

分析：这是一道广为流传的面试题，包括百度、微软和Google在内的多家公司
都曾经采用过这个题目。要几十分钟的时间里很好地解答这道题，除了较好的编程能力之外，
还需要较快的反应和较强的逻辑思维能力。

+-1 ，计数法




题目大意如下：
一排N（最大１Ｍ）个正整数+1递增，乱序排列，第一个不是最小的，把它换成-1，
最小数为ａ且未知求第一个被-1替换掉的数原来的值，并分析算法复杂度。


4.给出洗牌的一个算法，并将洗好的牌存储在一个整形数组里。 




在一维坐标轴上有n个区间段，求重合区间最长的两个区间段。 




16、正整数序列Q中的每个元素都至少能被正整数a和b中的一个整除，现给定a和b，需要计算出Q中的前几项，例如，当a=3，b=5，N=6时，序列为3，5，6，9，10，12
(1)、设计一个函数void generate（int a,int b,int N ,int * Q）计算Q的前几项
(2)、设计测试数据来验证函数程序在各种输入下的正确性。




57、求最大重叠区间大小

题目描述：请编写程序，找出下面“输入数据及格式”中所描述的输入数据文件中最大重叠区间的大小。 
对一个正整数 n ，如果n在数据文件中某行的两个正整数（假设为A和B）之间，即A<=n<=B或A>=n>=B ，则 n 属于该行；
如果 n 同时属于行i和j ，则i和j有重叠区间；重叠区间的大小是同时属于行i和j的整数个数。

例如，行（10 20）和（12 25）的重叠区间为 [12 20] ，其大小为9，行(20 10)和（ 20 30 ）的重叠区间大小为 1 。





给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。
要求：空间复杂度O(1)，时间复杂度为O（n）。


48、找出数组中唯一的重复元素


1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次．
每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间，
能否设计一个算法实现？


2.用递归的方法判断整数组a[N]是不是升序排列


给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。
要求：空间复杂度O(1)，时间复杂度为O（n）。





35.
求一个矩阵中最大的二维矩阵(元素和最大).如:
1 2 0 3 4
2 3 4 5 1
1 1 5 3 0
中最大的是:
4 5
5 3
要求:(1)写出算法;(2)分析时间复杂度;(3)用C写出关键代码



1.对于一个整数矩阵，存在一种运算，对矩阵中任意元素加一时，需要其相邻（上下左右）某一个元素也加一，

现给出一正数矩阵，判断其是否能够由一个全零矩阵经过上述运算得到。



38、顺时针打印矩阵
题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
例如：如果输入如下矩阵：

1              2              3              4
5              6              7              8
9              10             11             12
13             14             15             16
则依次打印出数字1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10。

分析：包括Autodesk、EMC在内的多家公司在面试或者笔试里采用过这道题。




一个数组是由一个递减数列左移若干位形成的，比如{4，3，2，1，6，5}
是由{6，5，4，3，2，1}左移两位形成的，在这种数组中查找某一个数。 

 


俩个闲玩娱乐。
1.扑克牌的顺子
从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。
2-10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看成任意数字。   

2.n个骰子的点数。
把n个骰子扔在地上，所有骰子朝上一面的点数之和为S。
输入n，打印出S的所有可能的值出现的概率。

   

68.把数组排成最小的数。
题目：输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。
例如输入数组{32, 321}，则输出这两个能排成的最小数字32132。
请给出解决问题的算法，并证明该算法。

分析：这是09年6月份百度的一道面试题，
从这道题我们可以看出百度对应聘者在算法方面有很高的要求。


 

69.旋转数组中的最小元素。

题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个排好序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。

分析：这道题最直观的解法并不难。从头到尾遍历数组一次，就能找出最小的元素，
时间复杂度显然是O(N)。但这个思路没有利用输入数组的特性，我们应该能找到更好的解法。

 


71.数值的整数次方。
题目：实现函数double Power(double base, int exponent)，求base的exponent次方。
不需要考虑溢出。

分析：这是一道看起来很简单的问题。可能有不少的人在看到题目后30秒写出如下的代码：
double Power(double base, int exponent)
{
  double result = 1.0;
  for(int i = 1; i <= exponent; ++i)
  result *= base;
  return result;
}







61.找出数组中两个只出现一次的数字
题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。
请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

分析：这是一道很新颖的关于位运算的面试题。


 
64. 寻找丑数。
题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number）。
例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。
求按从小到大的顺序的第1500个丑数。

分析：这是一道在网络上广为流传的面试题，据说google曾经采用过这道题。

 


65.输出1到最大的N位数
题目：输入数字n，按顺序输出从1最大的n位10进制数。
比如输入3，则输出1、2、3一直到最大的3位数即999。

分析：这是一道很有意思的题目。看起来很简单，其实里面却有不少的玄机。

 


一个有序数列，序列中的每一个值都能够被2或者3或者5所整除，1是这个序列的第一个元素。求第1500个值是多少？

1，2，3，4，5，6，8，9，10，12，14，15，16,...

1）所有的偶数都在序列中
2）3的倍数也在序列中
3）5的倍数也在系列中
unsigned long value_in_sequence(int index)

0. 2，3，5最小公倍数是30
1. [1,30]符合条件有22个
2. [30,60]符合条件也22个

第1500个： 1500/22=68余4，一个周期内的前4个数是2，3，4，5； 最终答案是`68*30+5`



和为n连续正数序列。
题目：输入一个正数n，输出所有和为n连续正数序列。

例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以输出3个连续序列1-5、4-6和7-8。




 

54.调整数组顺序使奇数位于偶数前面。

题目：输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，

所有偶数位于数组的后半部分。要求时间复杂度为O(n)。

 
47.创新工场：
求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}

 


有一个整数数组，请求出两两之差绝对值最小的值,
记住，只要得出最小值即可，不需要求出是哪两个数。

如 [-1， 3， 5， 9] 绝对值最小的是2（5-3）
最短区间问题
如果是有重复元素，那最小值就是0了






12、一个整数数列，元素取值可能是0~65535中的任意一个数，相同数值不会重复出现。0是例外，可以反复出现。
请设计一个算法，当你从该数列中随意选取5个数值，判断这5个数值是否连续相邻。
注意：
- 5个数值允许是乱序的。比如： 8 7 5 0 6
- 0可以通配任意数值。比如：8 7 5 0 6 中的0可以通配成9或者4
- 0可以多次出现。
- 复杂度如果是O(n2)则不得分。



一个整数数列，元素取值可能是1~N（N是一个较大的正整数）中的任意一个数，相同数值不会重复出现。
设计一个算法，找出数列中符合条件的数对的个数，满足数对中两数的和等于N+1。
复杂度最好是O(n)，如果是O(n2)则不得分。




56、一个含n个元素的整数数组至少存在一个重复数，
请编程实现，在O（n）时间内找出其中任意一个重复数。




在排序数组中，找出给定数字的出现次数
比如 [1, 2, 2, 2, 3] 中2的出现次数是3次。
分析：
1. 因为是排序数组，可以使用二分查找
2. 将二分查找坚持到底，这样在最坏的情况下([2,2,2,2,2,2,2])都有0(lgn)复杂度
int binary_search_first(int *a,int length,int key);
int binary_search_lash(int *a,int length,int key);




53、最长递增子序列

题目描述：设L=<a1,a2,…,an>是n个不同的实数的序列，L的递增子序列是这样一个子序列

Lin=<aK1,ak2,…,akm>，其中k1<k2<…<km且aK1<ak2<…<akm。
求最大的m值。












