
《剑指offer》 这本书给出了50到面试题，涉及到字符串处理，堆栈，链表，二叉树等问题的处理。

代码鲁榜性：边界条件，特殊输入，异常处理：空指针  
分析方法：画图，举例，分解

查找和排序是常考：重点掌握二分查找，快速排序，归并排序


1  赋值运算符函数
2  实现Singleton模式


3  二维数组中的查找。二维数组中每一行从左到右递增，每一列从上到下递增



4 替换空格。把字符串中的每个空格替换成 %20
`二遍扫描` 



5 从尾到头打印链表
`栈`



6 重建二叉树。输入某二叉树的前序遍历和中序遍历的结果，重建该二叉树




7 用两个栈实现队列



8 旋转数组的最小数字


9 菲波那切数列


10 二进制中1的个数
`n=n&n-1`



11 数值的整数次方。实现 double power(double base,int exponent)




12 打印1到最大的n位数。 比如n=3，就打印1到999




13 在O(1)时间删除链表节点，有一个头节点指针，还有一个指向改删除节点的指针
`用下一个节点的内容覆盖当前删除节点的内容，删除下一个节点`


14 调整数组顺序使奇数位于偶数前面。调整后，所有奇数在前半部分，偶数在后半部分
`两边向中间扫描`



15 输出链表中倒数第K个节点
`使用两个指针，一个先走k-1步`



16 反转链表
`三个指针`



反转二叉树


17 合并2个排序的链表，合并以后任然排序
`递归`



18 树的子结构，二叉树的基本操作



19 二叉树翻转
		8   				8
	   / \				   / \
	  /   \				  /   \   						
	 6     10	 翻转后	10	   6
	/ \	   / \          / \   / \
   5   7  9  11   	   11  9 7   5
   
	   
`交换每个节点的左右子树`	   



20 从外向里顺时针打印矩阵


延伸：按大小顺序打印矩阵

21 实现一个能找到栈的最小元素的函数
`最小元素用辅助栈保存`


22 栈的压入，弹出序列


23 从上往下打印二叉树
`辅助队列`


24 二叉搜索树的后续遍历序列。
输入一个整数数组，判断该数组是不是某二叉查找树的后续遍历序列的结果

`寻找规律`

【 5，7，6，9，11，10，8】 是下面儿茶查找树的后续遍历结果：

		8   			
	   / \				   
	  /   \				    						
	 6     10	 
	/ \	   / \         
   5   7  9  11   	   




25 二叉树中和为某一值的路径

	   10   			
	   / \				   
	  /   \				    						
	 5     12	 
	/ \	           
   5   7    

和为22的路径有2条：10--5--7， 10--12

`递归，栈`



26 复杂链表的复制




27 二叉搜索树与双向链表。将二叉搜索树转换成一个排序的双向链表，只调整树中节点的指针指向

`递归` `分解问题`



28 字符串的排列。输入一个字符串，打印该字符串中字符的所有排列
`递归，分解`


29 数组中出现次数超过一半的数字

```
int moreThanHalfNum(int *nums ,int length)
```
`遍历数组，下一个数字和之前保存的数字一样就+1，否则就-1`


30 最小的K个数

`快速排序` `最大堆`


最大的K个数


31 连续子数组的最大和

`分析规律` `动态规划`


32 从1到n整数中，1出现的次数
比如 12，从1到12这些整数中，包含1的数字有 1， 10，11，12 ，1出现了5次

``


33 把数组排成最小的数
输入一个正整数数组,把所有数字拼起来排出一个最小数

```
int minNumber(int *nums, int length);
```

34  丑数

> 只包含因子 2，3，5的数叫做丑数



35  第一个只出现一次的字符
`哈希表：值为出现的次数` `二次扫描`



36  数组中的逆序对
数组中的两个数字如果前面一个数字大于后面的数字，这两个数字组成一个逆序对
如：[7，5，6，4] 的逆序对：(7,5)(7,6)(7,4)(5,4)(6,4)

`归并排序 O(nlogn),空间O(n)`



37  两个链表的第一个公共节点
`长的链表先走k步`



38 数字在排序数组中出现的次数
比如 {1，2，3，3，3，3，4，5}， 数字 3出现了4从
`使用二分查找找第一个3，和最后一个3出现的位置`


```
int appearCount(int *nums,int length);
```


39  二叉树的深度
`递归`


```
int treeDepth(BTree *root);
```

40 数组中只出现一次的数字
数组中除了2个数字之外，其他的数组都出现了2次，找出这两个数

`异或` `二进制`

>如果是只有1个数字只出现一次，我们可以通过对数组依次做异或运算。

如果我们能把原数组分成2个子数组，每个子数组都包含一个只出现一次的数字，问题就能解决了。我们把数组中的所有数字依次做异或操作，如果有2个数字不一样，结果肯定不是0，且异或结果数字的二进制表示中至少有一位是1（不然结果不就是0了）

1. 在结果数字二进制表示中找到第一个为1的位的位置，标记n
2. 以二进制表示中第n位是不是1为标准，把原数组分成2个子数组




41 和为s的两个数字 VS  和为s的连续正数序列

有一个递增排序数组，和一个数字s，找出数组中的2个数，使得和等于s。输出任意一对即可

`两边向中间扫描`


42 反转单词顺序 VS 左旋转字符串

1. 翻转句子中单词的顺序，但单词内字符不变。如 『I am a student』 ->  『student. a am I』
`先以单词为单位翻转,整个句子再次翻转`

2. 左旋转字符串是把字符串其那面的若干位转义到字符串的尾部。比如"abcedfsz"和数字2，结果是"cedfszab"

```
char *left_rotate_string(char *s,int n)
```


43 n个色子的点数

把n个色子丢地上，朝上一面的点数之和为s。输入n，打印可能的值出现的概率


44 扑克牌中的顺子

从扑克牌从随机抽5张牌，判断是不是顺子。A是1，J~K是11~13，大小王可以看出任意数字。



45 圆圈中最后剩下的数字(约瑟夫问题)

0,1,...,n-1 这n个数字排成一个圆圈，从数字0开始从这个圆圈里面删除第m个数字，求出这个圆圈里最后剩下的数字。


46 求 1+2+...+n。要求不用乘除法，for/while/if/else/switch等关键字及条件判断语句



47 不用加减乘除做加法
`位运算`


48 不能被继承的类


49 把字符串转换成整数。比如 "12343567754" -> 12343567754

``
int strToInt(char str);
```
`NULL,空串,正负号,溢出`


50 树中2个结点的最低公共祖先

如果这个树是二叉排序树
如果不是二叉排序树，但是有父节点指针
如果不是二叉树，也没有父节点指针
















