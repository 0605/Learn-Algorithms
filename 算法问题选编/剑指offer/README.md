
《剑指offer》 这本书给出了50到面试题，涉及到字符串处理，堆栈，链表，二叉树等问题的处理。

代码鲁榜性：边界条件，特殊输入，异常处理：空指针  
分析方法：画图，举例，分解

查找和排序是常考：重点掌握二分查找，快速排序，归并排序


1  赋值运算符函数
2  实现Singleton模式


3  二维数组中的查找。二维数组中每一行从左到右递增，每一列从上到下递增



4 替换空格。把字符串中的每个空格替换成 %20
`二遍扫描` 



5 从尾到头打印链表
`栈`



6 重建二叉树。输入某二叉树的前序遍历和中序遍历的结果，重建该二叉树




7 用两个栈实现队列



8. 旋转数组的最小数字


9. 菲波那切数列


10. 二进制中1的个数
`n=n&n-1`



11. 数值的整数次方。实现 double power(double base,int exponent)




12. 打印1到最大的n位数。 比如n=3，就打印1到999




13. 在O(1)时间删除链表节点，有一个头节点指针，还有一个指向改删除节点的指针
`用下一个节点的内容覆盖当前删除节点的内容，删除下一个节点`


14. 调整数组顺序使奇数位于偶数前面。调整后，所有奇数在前半部分，偶数在后半部分
`两边向中间扫描`



15. 输出链表中倒数第K个节点
`使用两个指针，一个先走k-1步`



16. 反转链表
`三个指针`



反转二叉树


17. 合并2个排序的链表，合并以后任然排序
`递归`



18. 树的子结构，二叉树的基本操作



19. 二叉树翻转
		8   				8
	   / \				   / \
	  /   \				  /   \   						
	 6     10	 翻转后	10	   6
	/ \	   / \          / \   / \
   5   7  9  11   	   11  9 7   5
   
	   
`交换每个节点的左右子树`	   



20. 从外向里顺时针打印矩阵


21. 实现一个能找到栈的最小元素的函数
`最小元素用辅助栈保存`


22. 栈的压入，弹出序列


23. 从上往下打印二叉树
`辅助队列`


24. 二叉搜索树的后续遍历序列。
输入一个整数数组，判断该数组是不是某二叉查找树的后续遍历序列的结果

`寻找规律`

【 5，7，6，9，11，10，8】 是下面儿茶查找树的后续遍历结果：

		8   			
	   / \				   
	  /   \				    						
	 6     10	 
	/ \	   / \         
   5   7  9  11   	   




25. 二叉树中和为某一值的路径

	   10   			
	   / \				   
	  /   \				    						
	 5     12	 
	/ \	           
   5   7    

和为22的路径有2条：10--5--7， 10--12

`递归，栈`



26. 复杂链表的复制




27. 二叉搜索树与双向链表。将二叉搜索树转换成一个排序的双向链表，只调整树中节点的指针指向

`递归，分解问题`



28. 字符串的排列。输入一个字符串，打印该字符串中字符的所有排列
`递归，分解`


29. 数组中出现次数超过一半的数字

```
int moreThanHalfNum(int *nums ,int length)
```
`遍历数组，下一个数字和之前保存的数字一样就+1，否则就-1`


30. 最小的K个数

`快速排序` `最大堆`


最大的K个数


31. 连续子数组的最大和

`分析规律` `动态规划`


32. 从1到n整数中，1出现的次数
比如 12，从1到12这些整数中，包含1的数字有 1， 10，11，12 ，1出现了5次

``


33.把数组排成最小的数
输入一个正整数数组,把所有数字拼起来排出一个最小数

```
int minNumber(int *nums, int length);
```

34. 丑数

> 只包含因子 2，3，5的数叫做丑数



35. 第一个只出现一次的字符
`哈希表：值为出现的次数` `二次扫描`



36. 数组中的逆序对
数组中的两个数字如果前面一个数字大于后面的数字，这两个数字组成一个逆序对
如：[7，5，6，4] 的逆序对：(7,5)(7,6)(7,4)(5,4)(6,4)

`归并排序 O(nlogn),空间O(n)`



37. 两个链表的第一个公共节点
`长的链表先走k步`



38. 数字在排序数组中出现的次数
比如 {1，2，3，3，3，3，4，5}， 数字 3出现了4从
`使用二分查找找第一个3，和最后一个3出现的位置`


```
int appearCount(int *nums,int length);
```


39. 二叉树的深度
`递归`


```
int treeDepth(BTree *root);
```

40. 数组中只出现一次的数字




41. 和为s的两个数字 VS  和为s的连续正数序列


42. 反转单词顺序 VS 左旋转字符串


43. n个色子的点数


44. 扑克牌中的顺子



45. 圆圈中最后剩下的数字


46. 求 1+2+...+n



47. 不用加减乘除做加法


48. 不能被继承的类


49. 把字符串转换成整数


50. 树中2个结点的最低公共祖先














