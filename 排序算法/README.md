
## 排序算法

**排序的稳定性** 对于相等的元素，排序之后，任然保存2个元素的位置没有变，就是稳定的排序，反之就是不稳定排序。



### 直接选择排序

1. 从未排序的序列中选择最小的元素，放在第一个位置
2. 依次类推，直到全部排序

在a【i,n】中最小的元素和 a[i]交换位置。空间复杂度O(1)，时间复杂度 O(n^2)


### 堆排序

利用堆这种数据结构设计的一种排序算法
将待排序数列看做一颗完全二叉树的存储结构
堆总是一颗完全树，
堆也被称为`优先队列`，


堆分小根堆和大根堆

堆： 任一节点小于（或大于）其所有的孩子节点，如果是大于所有孩子节点，这就是一颗大根堆，也就是根节点是堆上的最大值；如果节点小于所有的子节点，这就是一颗小跟堆，也即是根节点是堆上所有节点的最小值。

按层遍历堆既可以得到一个排好顺序的序列。


堆排序主要时间花在建堆期间，找数列中最大树只需要O(1)时间复杂度







### 快速排序

1. 从数列中选择一个元素，作为基准 pivot
2. 重排数列，比 pivot 小得排左边，比pivot大的排右边，相等的随便
3. 递归的，使用相同的方式，重排左右两边的子序列

递归一次，pivot 左边都比它小，右边都比它大
这是递归，分治的思想

平均复杂度 O(n*logn)






### 冒泡排序

相邻的2各元素比较，大的向后移，经过一轮比较，做大的元素排在最后
第二轮，第二大的元素排倒数第二个位置
直到全部排好

这样，即使是排好序的拿冒泡排序排序，比较的时间复杂度O(n^2)




### 插入排序

1. 第一个元素算作已经排好
2. 取下一个元素，从已经排好的序列元素中，从后向前扫描
3. 如果排好序的元素大于 新元素，排好序的元素一道下一个位置
4. 重复3，直到直到最后的插入位置
5. 重复2

最坏的情况： 待排序的是一个逆序排放的数组，这样导致每一轮都要移动元素；此时复杂度是是0(n^2) 
最好的情况： 待排序的是一已经顺序排放的数字，此时只需要做一轮比较就够了 0（n）

空间复杂度O（1）




### 希尔排序



### 归并排序



### 基数排序



### 总结

常见的排序算法都是比较排序，比较排序的时间复杂度通常为 O(n^2) 或 O(nlogn)
























